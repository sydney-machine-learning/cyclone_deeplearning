# -*- coding: utf-8 -*-
"""cat_prediction_univariate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oXz5Pbd7TusaLgsAp35MMi-0drZ1WWLl
"""

import copy
import numpy as np
import sklearn
import pandas as pd
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Bidirectional
from keras.layers import RepeatVector
from keras.layers import TimeDistributed
from numpy import hstack
from sklearn.preprocessing import StandardScaler
import datetime
import time
import joblib
from datetime import timedelta, date
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler
from numpy import array
import matplotlib.pyplot as plt
import os
import seaborn as sns; sns.set_theme() 
import errno
from keras.layers.convolutional import Conv1D
from keras.layers.convolutional import MaxPooling1D
from keras.layers import Flatten
from keras.layers import ConvLSTM2D

def load_data(url):
  df = pd.read_csv(url, sep = "\t", header = None)
  df.columns = ['id','date','longitude','latitude','speed']
  df = df.drop(['date'], axis = 1)
  df['category'] = df['speed'].apply(lambda x: 
  1 if x<=27 else 2  if x<=33 and x> 27 else 3 if x<=47 and x> 33 else 4 if x<=63 and x> 47 else 5 if x<=89 and x> 63 else 6 if x<=119 and x>89 else 7 )
  return df

url = 'https://raw.githubusercontent.com/sydney-machine-learning/cyclone_deeplearning/main/data/SouthIndianOcean/misc/rawtrain1985-2001.txt'
df = load_data(url)
df

df.info()

df.describe()

def split_sequence(sequence, n_steps_in, n_steps_out):
    X, y = list(), list()
    for i in range(len(sequence)):
        # find the end of this pattern
        end_ix = i + n_steps_in
        out_end_ix = end_ix + n_steps_out
        # check if we are beyond the sequence
        if out_end_ix > len(sequence):
            break
        # gather input and output parts of the pattern
        seq_x, seq_y = sequence[i:end_ix], sequence[end_ix:out_end_ix]
        X.append(seq_x)
        y.append(seq_y)
    return np.array(X), np.array(y)
 
def rmse(pred, actual):
  return np.sqrt(((pred-actual) ** 2).mean())

def bidirectional(hidden,n_steps_in,n_steps_out,n_features):
  model = Sequential()
  model.add(Bidirectional(LSTM(Hidden, activation='relu'), input_shape=(n_steps_in, n_features)))
  model.add(Dense(n_steps_out))
  model.compile(optimizer='adam', loss='mse')
  return model

def cat_calc(tsd): 
    output=np.empty(len(tsd))
    for i in range(len(tsd)):
        if tsd[i]<=27:
            output[i]=1
        elif tsd[i]>27 and tsd[i]<=33:
            output[i]=2
        elif tsd[i]>33 and tsd[i]<=47:
            output[i]=3
        elif tsd[i]>47 and tsd[i]<=63:
            output[i]=4
        elif tsd[i]>63 and tsd[i]<=89:
            output[i]=5
        elif tsd[i]>89 and tsd[i]<=119:
            output[i]=6
        else:
            output[i]=7
    return output

#all models
def MODEL_LSTM(univariate, x_train, x_test, y_train, y_test, Num_Exp, n_steps_in, n_steps_out, Epochs, Hidden):

    train_acc = np.zeros(Num_Exp)
    test_acc = np.zeros(Num_Exp)
    model = bidirectional(Hidden,n_steps_in,n_steps_out,n_features)    
    model.summary()

    y_predicttest_allruns = np.zeros([Num_Exp, x_test.shape[0], y_test.shape[1]])

    print(y_predicttest_allruns.shape, ' shape ')


    Best_RMSE = 1000  # Assigning a large number
    start_time = time.time()
    for run in range(Num_Exp):
        print("Experiment", run + 1, "in progress")
        # fit model
        model.fit(x_train, y_train, epochs=Epochs, batch_size=10, verbose=0, shuffle=False)
        y_predicttrain = model.predict(x_train)
        y_predicttest = model.predict(x_test)
        y_predicttest_allruns[run,:,:] = y_predicttest
        train_acc[run] = rmse(y_predicttrain, y_train)
        print(train_acc[run], 'train accuracy')
        test_acc[run] = rmse(y_predicttest, y_test)
        print(test_acc[run], 'test accuracy')
        if test_acc[run] < Best_RMSE:
            Best_RMSE = test_acc[run]
            Best_Predict_Test = y_predicttest
        
    train_std = np.std(train_acc)
    test_std = np.std(test_acc)
    print("Total time for", Num_Exp, "experiments", time.time() - start_time)
    return train_acc, test_acc, train_std, test_std, Best_Predict_Test, y_predicttrain, y_predicttest, y_predicttest_allruns

univariate = True # if false, its multivariate case
n_steps_in = 5
n_seq = 2
n_steps_out = 1
n_features = 1 # for univariate
Hidden = 10
Epochs = 50
Num_Exp = 5

speed = df['speed'].tolist()
len(speed)

total = len(speed)
train = speed[0:int(total*80/100)]      # 80 % data for training 
test = speed[int(total*80/100):]
x_train, y_train = split_sequence(train, n_steps_in, n_steps_out)
x_test, y_test = split_sequence(test, n_steps_in, n_steps_out)
x_train = x_train.reshape((x_train.shape[0], x_train.shape[1], n_features))
x_test = x_test.reshape((x_test.shape[0], x_test.shape[1], n_features))
y_train = y_train.reshape((y_train.shape[0],n_steps_out))
y_test = y_test.reshape((y_test.shape[0],n_steps_out))

print(x_train.shape, x_test.shape, y_train.shape, y_test.shape)
train_acc, test_acc, train_std_dev, test_std_dev, best_perdicttest, y_predicttrain, y_predicttest, y_predicttest_allruns = MODEL_LSTM(univariate,x_train,x_test,y_train,y_test,Num_Exp,n_steps_in,n_steps_out,Epochs, Hidden)
mean_train = np.mean(train_acc, axis=0)
mean_test = np.mean(test_acc, axis=0)
train_std = train_std_dev
test_std = test_std_dev
best_predict_test = best_perdicttest.tolist()
y_predict_train = y_predicttrain.tolist()
y_predict_test = y_predicttest.tolist()
print('---------------------------------------------------') 
print(mean_train, 'mean rmse train') 
print(mean_test, 'mean rmse test')
print(train_std, 'std train') 
print(test_std, 'std test')

actual_cat_train=cat_calc(y_train)
predicted_cat_train=cat_calc(y_predicttrain)

#Calculate the Categories for Test
actual_cat_test=cat_calc(y_test)
predicted_cat_test=cat_calc(best_perdicttest)

#Check RMSE
train_acc=rmse(predicted_cat_train,actual_cat_train)
test_acc=rmse(predicted_cat_test,actual_cat_test)

print(train_acc, 'is the category pred RMSE for the Train Data') 
print(test_acc, 'is the category pred RMSE for the Test Data')

xi = list(range(len(actual_cat_test)))
fig = plt.subplots(figsize =(12, 8))
plt.plot(xi,actual_cat_test, label='Actual Category')
plt.plot(xi,predicted_cat_test, label='Predicted Category')
plt.xlabel('index')
plt.ylabel('category')
plt.title('Cyclone category')
plt.legend()
plt.savefig('cat_pred.png')

